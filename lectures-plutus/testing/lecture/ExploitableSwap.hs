{-# LANGUAGE DataKinds           #-}
{-# LANGUAGE ImportQualifiedPost #-}
{-# LANGUAGE NoImplicitPrelude   #-}
{-# LANGUAGE OverloadedStrings   #-}
{-# LANGUAGE TemplateHaskell     #-}

module ExploitableSwap where

import           PlutusLedgerApi.V2          (PubKeyHash,
                                              ScriptContext (scriptContextTxInfo),
                                              adaSymbol, adaToken, singleton)
import           PlutusLedgerApi.V2.Contexts (TxInfo, valuePaidTo)
import           PlutusTx                    (CompiledCode, compile,
                                              unstableMakeIsData)
import           PlutusTx.Builtins           (BuiltinData, Integer)
import           PlutusTx.Prelude            (Bool (..), traceIfFalse)
import           Utilities                   (wrapValidator)
import           PlutusLedgerApi.V1.Value    (geq)

---------------------------------------------------------------------------------------------------
----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------

data DatumSwap = DatumSwap
  { beneficiary :: PubKeyHash
  , price       :: Integer
  }
PlutusTx.unstableMakeIsData ''DatumSwap

{-# INLINABLE mkValidator #-}
mkValidator :: DatumSwap -> () -> ScriptContext -> Bool
mkValidator ds _ ctx = traceIfFalse "Hey! You have to pay the owner!" outputToBeneficiary
    where
        txInfo :: TxInfo
        txInfo = scriptContextTxInfo ctx

        outputToBeneficiary :: Bool
        outputToBeneficiary =
          valuePaidTo txInfo (beneficiary ds) `geq` singleton adaSymbol adaToken (price ds)


{-# INLINABLE  mkWrappedValidator #-}
mkWrappedValidator :: BuiltinData -> BuiltinData -> BuiltinData -> ()
mkWrappedValidator = wrapValidator mkValidator


validator :: CompiledCode (BuiltinData -> BuiltinData -> BuiltinData -> ())
validator = $$(compile [|| mkWrappedValidator ||])