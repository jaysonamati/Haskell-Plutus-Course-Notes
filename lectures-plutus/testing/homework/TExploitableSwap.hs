{-# LANGUAGE NoImplicitPrelude  #-}
{-# LANGUAGE NumericUnderscores #-}
{-# LANGUAGE OverloadedStrings  #-}

module Main where

import           Control.Monad           (mapM, replicateM)
import           Plutus.Model            (Ada (Lovelace), DatumMode (HashDatum),
                                          Run, Tx, UserSpend, FakeCoin (FakeCoin), TypedValidator, ada, adaValue, fakeValue,
                                          currentTimeRad, defaultBabbage,
                                          initMock, mustFail, testNoErrors, newUser, payToKey,
                                          payToScript, runMock, spend,
                                          spendScript, submitTx, userSpend,
                                          utxoAt, validateIn, valueAt,
                                          waitUntil)
import           PlutusLedgerApi.V2      (POSIXTime (POSIXTime, getPOSIXTime),
                                          PubKeyHash, TxOut (txOutValue),
                                          TxOutRef, Value)
import           PlutusTx.Builtins       (Integer, mkI)                                    
import           PlutusTx.Prelude        (($))
import           Prelude                 (IO, Int, (.), (<>), undefined, mconcat)
import qualified ExploitableSwap         as OnChain
import           Test.Tasty              (defaultMain, testGroup)
import           Plutus.Model.V1         (mkTypedValidator)


---------------------------------------------------------------------------------------------------
------------------------------------------ TESTING ------------------------------------------------

main :: IO ()
main = do
  defaultMain $ do
    testGroup
      "Catch double spend with testing"
      [ good "Normal spending" normalSpending
      , bad  "Double spending" doubleSpending
      ]
 where
    bad msg = good msg . mustFail
    good = testNoErrors (adaValue 10_000_000 <> fakeValue scToken 100) defaultBabbage

---------------------------------------------------------------------------------------------------
----------------------------- HELPER FUNCTIONS/INSTANCES/TYPES ------------------------------------

scToken :: FakeCoin
scToken = FakeCoin "Super-Cool-Token"
 
type HomeworkScript = TypedValidator OnChain.DatumSwap ()

-- Set many buying users at once
setupBuyingUsers :: Int -> Run [PubKeyHash]
setupBuyingUsers n = replicateM n $ newUser $ ada (Lovelace 1_000)

-- Set many selling users at once
setupSellingUsers :: Int -> Run [PubKeyHash]
setupSellingUsers n = replicateM n $ newUser $ (ada (Lovelace 1_000) <> fakeValue scToken 10)

swapScript :: HomeworkScript
swapScript = mkTypedValidator OnChain.validator

-- Create a transaction that spends "usp" to lock "val (coin to swap)" in "swapScript"
lockingTx :: PubKeyHash -> Integer -> UserSpend -> Value -> Tx
lockingTx beneficiary price usp val = 
    mconcat
        [ userSpend usp
        , payToScript swapScript (HashDatum (OnChain.DatumSwap beneficiary price)) val
        ]

consumingTx :: undefined
consumingTx = undefined

doubleConsumingTx :: undefined
doubleConsumingTx = undefined

---------------------------------------------------------------------------------------------------
-------------------------------------- TESTING SPENDING -------------------------------------------

normalSpending :: Run ()
normalSpending = undefined


doubleSpending :: Run ()
doubleSpending = undefined